## 네트워크 기본 1 -  컴퓨터네트워크 및 인터넷 역사 (1)

### 네트워크 구조

- end systems(hosts) : 인터넷에 연결되는 많은 End system들을 의미

- client/server model

  - 클라이언트 호스트는 서버로부터 서비스를 요청/수신한다. (웹 브라우저/서버, 이메일클라이언트/서버)

- peer-peer model

  - minimal use of dedicated servers  

  

### 네트워크 edge (가장자리)

- **애플리케이션**들과 **호스트**들 
- 호스트는 때때로 client/server로 구분됨.



### 네트워크 Core

- routers 
- network of networks

#### Access networks, physical media

- 통신 링크들 (comm links)
  - 엔드 시스템들은 **통신링크**와 **패킷 스위치** 의 네트워크로 연결된다. 
    - 통신 링크는 여러 물리매체로 구성된다. 
    - 각각의 링크들은 다양한 정송률(transmission rate, 링크 대역폭)을 이용하여 데이터를 전송함.
    - 전송률은 bps(bit per second)가 기본 
  - packet : 송신 종단 시스템은 해당 데이터를 세그먼트로 나누고 각 세그먼트에 header를 붙인다. 패킷은 이러한 정보 패키지를 일컫는다. 목적지에서 원래의 데이터로 다시 조립됨.
  - 패킷 스위치 : 도착하는 패킷을 받아서 출력통신 링크의 하나로 그 패킷을 전달하는 기능을 담당하는 입력 통신링크. 패킷스위치 종류는 아래와 같다.
    - 1) 라우터
      - 네트워크 코어에서 사용됨 
    - 2) 링크 계층 스위치 
      - 액세스 네트워크에서 사용 







## Network edge: connection-oriented service (연결 기반 서비스)

목적 : 엔드 시스템간의 데이터 전송

#### Connection 이란?

- 데이터 전송 이전에 준비단계가 있는 것을 의미한다. 

- Request / respond

  ```tex
  TCP 연결 요청 ->
        <-TCP 연결요청에 대한 응답
  -> 요청
        <- 응답 파일 등의 형식
  
  ```

  

- 두 호스트의 통신에서 state를 설정하는 것 등을 의미

### TCP (Transmission Control Protocol)

- 정의 : **인터넷의 연결 기반 서비스**를 TCP라 한다.
- **1) reliable , in-order, byte-stream data transfer (신뢰할 수 있는, 순서가 보장도니 바이트 스트림 데이터 전송)**
  - loss 에 대해 손실을 인지하고, 재전송 가능
- **2) flow control (흐름 제어)**
  - 정보 전달자(sender)가 수신자(receiver)의 용량을 초과하지 않게 데이터 전송하는 흐름제어를 할수 있게 해준다.
- **3) congestion control (혼잡 제어)**
  - sender는 네트워크가 혼잡한 상태일 때, 발송률(sending rate)을 늦출 수 있다. 
  - 긴 메시지를 짧은 메시지로 나누기 등의 혼잡제어 기능 제공



#### TCP 사용하는 애플리케이션

- HTTP(web) , FTP, Telnet(remote login), SMTP(email)



### cf : IP

- 라우터와 엔드 시스템 사이에서 송수신되는 패킷 포맷 기술



## Network edge: connectionless service(무연결 서비스)

### UDP (User Datagram Protocol)

- 목적은 동일하나…신뢰할만한 데이터 전송이 아님(유실가능) 흐름제어 없음, 혼잡제어 없음 
- **connectionless**
- **unreliable data transfer**
- **no** flow control
- **no** congestion control



#### UDP 사용하는 앱

- streaming media, teleconferencing, DNS, Internet telephony  (voip 등)





## Network Core

- 서로 연결된 라우터의 망 (mesh)

- 데이터를 네트워크를 통해서 전송하는 방식은 두가지 존재
  - 1) circuit switching : 전화 연결망처럼 call 당 할당되는 circuit이 존재
    - end - end 자원은 call에 대해 예약되어있다. 지정할당된 자원에 대한 공유 없음. call setup이 요구됨
    - 가령 1 Mb/s link에 대해 유저가 10명이라면, 
      - 각 유저별로 active 상태에서 100 kb/s 통신 가능. 
  - 2) **packet switching**: 구분되는 chunks 단위로 데이터를 네트워크에 전달. **인터넷 방식**
    - 패킷들의 큐가 output link에 대해 존재. host A와 host B의 패킷들은 고정되지 않은 패턴으로, shared on demand (통계적 멀티플렉싱 방식)으로 전달된다. 
    - 패킷들이 라우터를 거쳐서 다른 end system의 input link로 전달된다.
    - 가령 1 Mb/s link에 대해
      - 제한은 없음. total 35 users에 대해 10명 이상이 동시 활동 중일 확률이 0.0004보다 적다면 무리없이 사용가능..but 동시접속자 몰리는 것에 대한 이슈는 존재 



## 패킷 딜레이의 4가지 요인

- 대부분의 패킷 스위치는 **저장 후 전달 방식(store and forward transmission)**을 이용

- 저장 후 전달 방식 : 스위치가 output link로 패킷의 **첫 비트를 전송하기 전에 전체 패킷을 받아야 함.**

- 가령, source 에서 destination으로 전송할 패킷이 3개이고, 각각 L비트로 구성, 라우터가 중간에 1개 인 경우

  - 송신 시스템은 패킷1의 일부분을 전송하고, 패킷1의 앞쪽은 이미 라우터에 도착. 
  - 라우터는 저장 후 전달 채택하고 있으므로 수신한 비트를 바로 전송 못함. 
  - 대신 해당 패킷의 비트를 먼저 저장한 후, 패킷의 모든 비트를 수신한 경우, output link로 그 패킷을 전송하기 시작. 송신 속도가 R(대역폭) bits/sec 라면 수신에 L/R이 소요

  

  - 이제 source가 **첫번째 패킷을 송신**하기 시작하면 **송신에 L/R**이 소요
  - 첫번째 패킷 송신완료와 동시에 L/R 시간에 source는 **두번째 패킷을 라우터에 송신**한다
  - 2L/R 시간에 목적지 노드는 첫번째 패킷을 수신한다. (라우터는 두번째 패킷을 수신완료한다.)
  - 3L/R 시간에 목적지 노드는 두번째 패킷까지 수신하게 되고, 라우터는 세번째 패킷을 수신완료한다
  - 4L/R 시간에 목적지노드는 3개의 패킷을 모두 수신한다.

- 즉, source —> destination 까지, **N개의 링크로 구성(N-1개의 라우터가 존재)** 되고,

   **각각이 R의 전송속도**를 갖는다면 end-to-end 지연은 **d = N*L/R** 이다.

  

#### 1) nodal processing (노드 처리 지연)

- bit errors, 패킷 헤더를 검사하는 과정
- 패킷을 보낼 output link 를 결정
- 수 millisec (0.001초 단위)

- **성능 좋은 라우터로 개선 가능** 

  



#### 2) queueing (큐잉 지연, 네트워크 지연의 핵심)

- 각각의 패킷 스위치(라우터)는 여러 개의 링크를 지님. 각 링크에 대해 패킷 스위치는 출력 버퍼(큐)를 지니고, 해당 링크로 송신하려는 패킷을 저장한다.

- output link에서 전송을 위해 패킷이 대기하는 시간

  - **큐가 비어있고**, **다른 패킷이 전송중인 상태가 아니면** 패킷의 큐잉지연은 0

- 라우터의 혼잡 수준에 따라 큐 대기 시간이 다르다. (millisec ~ 수 microsec (0.000001초 단위)

- **큐의 딜레이는 유저의 이용 정도에 따라 다름.** 

- **데이터 유실의 대부분의 원인은 큐가 터져서(overflow) 생김**

- **TCP에서** 유실된 데이터의 재전송은 중간 노드인 router가 아니라 **source가 담당**한다. 

  



#### 3) Transmission delay (전송 지연)

- 라우터가 **패킷을 내보내는데 걸리는 시간**

- R = link 대역폭(bps)
- L = 패킷 길이 (bits)
- link에 패킷을 전송하는 시간 = **L/R** =  **패킷 크기 / 대역폭**
  - **저장후 전송 방식**인 경우, 라우터는 L/R 초 시간동안 전체 패킷을 수신, 다시 L/R 초 시간동안 전체 패킷을 송신하므로, 전체 지연은 **2L/R** 이 된다. 

- **케이블 공사를 통해 대역폭 늘일 수 있음**

  

#### 4) Propagation delay (전파 지연)

- 마지막 비트가 링크에 올라온 후 **다음 라우터까지 도달하는데 걸리는 시간.**

- d = 물리적 링크(광케이블 등)의 길이
- s = 전송 매개체 내에서 전파 속도 (2*10^8m/sec)
- 전파 지연 = **d/s**
- **빛의 속도는 조작 불가**



#### 네트워크 프로토콜

- 둘 이상의 통신 개체간에 교환되는 메시지 포맷과 순서, 메시지 송수신과 다른이벤트에 따른 행동들을 정의하는 것.
- 인터넷의 모든 통신은 프로토콜들에 의해 이뤄진다.



## 계층에 따른 프로토콜

##  (프로토콜 스택 ; 다양한 계층의 프로토콜의 합)

- 인터넷 프로토콜 스택 : **[ 5개 ] 계층 ** 으로 구성 

#### 1. Application layer : HTTP, SMTP, FTP

- 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳. 
- 애플리케이션 계층 프로토콜은 여러 end system에 분산되어 있음. 
- 애플리케이션 계층 프로토콜: **end system 간의 패킷을 교환하는데 사용되는 프로토콜** 
- **Message** : App 계층 패킷



#### 2. Transport  layer : TCP UDP

- **클라이언트 / 서버** 간에 **애플리케이션 계층 메시지를 전송**하는 서비스를 제공

  - #### 1.데이터 통합(파일 전송, 웹 트랜잭션 등)과 관련된 기능 제공

  - #### 2.timing 

    - 몇몇 애플리케이션(인터넷 전화, 게임 등)은 효과적인 낮은 지연을 요구한다.

  - #### 3.throughput

    - 몇몇 애플리케이션(멀티미디어 등) 은 최소한의 산출량이 효과적이어야 한다.
    - 다른 앱들(엘라스틱 앱들)은 원하는 때에 언제든 산출이 가능해야 한다. 

  - #### 4.security 

    - 암호화, 데이터 통합 등 

    

- TCP와 UDP 라는 트랜스포트 프로토콜 존재. 

- TCP와 UDP는 App 계층 메시지를 전달.

- Segment : Transport 계층의 패킷을 의미  

- server 

  - 항상 host에 해당
  - 서버 프로세스 : 접촉을 기다리는 프로세스 
  - 고정 IP 주소 
  - 스케일링이 가능한 데이터 센터

- 클라이언트

  - 클라이언트 프로세스 : 통신을 처음 시작하는 프로세스 
  - 서버와 통신하는 주체
  - 동적 IP 주소 보유 가능
  - 클라이언트간에는 직접 통신 안함 
  - intermittently 연결되어있을 수 있음.

  

### 3. Network layer : IP

- 한 호스트에서 다른 호스트로 데이터그램(datagram) 을 라우팅하는 책임을 지니는 계층 

- 출발지 host 에서 인터넷 트랜스포트계층 프로토콜 **(TCP / UDP)**는 트랜스포트 계층 **세그먼트와** **목적지 주소를 네트워크 계층으로 전달.**

- 네트워크 계층은 **목적지 호스트의 트랜스포트 계층으로 세그먼트를 운반하는 서비스** 제공 

- IP 프로토콜 : 엔드 시스템과 라우터가 이 필드에서 동작하는 것을 정의한 프로토콜. 

  - 출발지와 목적지 사이에서 데이터그램이 이동하는 경로를 결정하는 라우팅 프로토콜을 포함 

  

### 4. Link layer : Wifi , LTE, Ethernet, 3G

- **전체 프레임을 한 네트워크요소 -> 이웃 네트워크 요소로 이동하는 서비스 제공** 

- 네트워크 계층은 출발지~목적지 간 일련의 패킷스위치(라우터)를 통해 데이터그램을 라우트 함
- 경로상의 한 노드(호스트 혹은 패킷 스위치)에서 다른 노드로 패킷을 이동하기 위해, Net 계층은 링크 계층 서비스에 의존. 
- 각 노드에서 **네트워크 계층은 데이터그램을 아래 링크 계층으로 보내고**, **링크계층은 해당 데이터그램을 경로상의 다음 노드에 전달.**
- Frame : 링크 계층 패킷을 의미 



### 5.physical layer 

- 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동하는 기능을 제공.
- 링크에 의존 + 링크의 실제 전송 매체에 의존.



OSI (Open system interconnection) 7계층

애플리케이션

**프레젠테이션** - 통신하는 애플리케이션들이 **교환되는 데이터의 의미를 해석하는 서비스**를 제공

- 데이터 압축, 컴퓨터 내부 포맷, 암호화 를 포함 

**세션**

- 데이터 교환의 경계 / 동기화를 제공
- 체크 포인트와 회복 방법을 세우는 수단 등을 포함 

전송

네트워크 

링크

물리



## 캡슐화 

출발지에서 다음과 같이 각 층으로 내려가면서 상위 계층(payload field)을 캡슐화하고, 추가적인 헤더 정보를 붙인다.

|            출발지 패킷 | 출발지 계층  |
| ---------------------: | :----------: |
|               메시지 M | 애플리케이션 |
|        세그먼트 H_t, M |  트랜스포트  |
| 데이터그램 H_n, H_t, M |   네트워크   |
| 프레임 H_I H_n, H_t, M |     링크     |
|                        |     물리     |

링크 계층 스위치(혹은 라우터) 에서는 프레임에 해당하는 정보를 갖고 있다.

라우터는 네트워크/링크에 해당하는 정보도 갖는다.



목적지에서는 출발지와 반대방향으로 패킷을 분해하면서 캡슐화된 정보를 하나씩 꺼낸다. 



## 소켓

- Application layer에서 process는 소켓을 통해 메세지를 주고 받을 수 있다.
- 소켓을 연결하는 것은 IP 주소(어떤 호스트?)와 Port(어떤 프로세스?)의 혼합으로 이뤄진다. 



#### 인터넷 애플리케이션들의 애플리케이션/트랜스포트 프로토콜

TCP - SMTP, Telnet, HTTP(web), FTP 

TCP or UDP - HTTP(streaming multimedia; Youtube) , 

TCP or UDP - 인터넷 전화 - SIP, RTP, proprietary(스카이프 등)



## HTTP 

- TCP를 사용. 

#### 동작 방식 

- 클라이언트는 TCP 연결을 시작(소켓 생성) 하여 서버에 연결. 포트는 범용적으로 80 사용
- 서버는 클라이언트로부터의 TCP 연결을 수락
- HTTP 메시지들이 브라우저와 웹 서버 간에 교환됨
- TCP 연결이 종료됨

#### HTTP는 statless이다.

- **서버는 과거의 클라이언트 요청에 대한 정보를 유지하지 않는다.**

- cf.과거의 상태를 유지하는 프로토콜은 복잡하다. 만약 서버/클라이언트 충돌시 상태가 부정확해진다.



## HTTP connections 

- TCP 연결을 지속적으로 사용할 것인지에 따라 나뉨

### 1) non-persistent HTTP

- 기껏해야 하나의 오브젝트가 TCP 연결을 통해 오간다.
- 전송후에 연결은 바로 종료된다.
- 여러 오브젝트 다운로드는 여러 연결이 필요 

##### 작동방식 (3 way/ 4way 혼재)

1a. **HTTP 클라이언트**는 HTTP 서버(www.abc.edu on port 80)로 **TCP  연결을 생성**한다.

1b. **HTTP 서버** 는 80포트에 대한 TCP 연결을 대기하다가 **"연결 수락"시, 클라이언트에 알린다.**

2. **HTTP 클라이언트는** HTTP 요청 메시지(url을 포함하는)를 TCP 연결 소켓을 통해 보낸다. 
   - 메시지는 클라이언트가 원하는 객체를 가리킨다.

3. **HTTP 서버는** 요청 메시지를 수신하고, 요청에 대한 객체를 포함한 응답 메시지를 생성하여, 서버의 소켓에 담아 HTTP 클라이언트로 보낸다.

4. **HTTP 서버는** 응답메시지와 함께 TCP연결이 종료됨을 알린다.

5. **HTTP 클라이언트는** 요청에 의한 응답 객체들을 수신한다.  
6. HTTP 클라이언트는 응답 객체 확인 후 TCP 연결 종료후 이를 서버에 알린다.
7. HTTP 서버는 클라이언트로부터 TCP 연결이 종료되었음을 확인하고, 소켓을 닫는다.



RTT : **클라이언트로부터 서버로, 그리고 서버에서 다시 클라이언트로** 돌아오는 **패킷의 도달 시간을 의미.** 

HTTP 응답 시간

- TCP 연결을 초기화하는 단계에서 **1 RTT 소요** (클라이언트 연결요청->서버 수락 후 알림->클라이언트 확인)

- HTTP 요청과 HTTP 응답이 처음으로 돌아오는데 **1 RTT가 소요**

- 파일 전송 시간은 별도로 소요

- #### non - persistent HTTP의 총 응답시간 = 2 RTT + 파일 전송 시간



### 2) persistent HTTP 

- 여러 오브젝트들이 클라이언트/서버 간의 단일 TCP 연결에 오고간다.
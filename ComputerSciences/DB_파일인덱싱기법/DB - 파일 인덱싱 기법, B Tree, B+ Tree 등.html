<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="author" content="hwj0623@naver.com"/><meta name="created" content="2017-11-03 11:20:30 +0000"/><meta name="source" content="desktop.mac"/><meta name="source-url" content="http://hochulshin.com/data-structure-b-tree/#간단한-규칙"/><meta name="updated" content="2017-11-05 14:28:11 +0000"/><title>DB - 파일 인덱싱 기법, B Tree, B+ Tree 등</title></head><body><div><span style="font-size: 24px;"><b>B 트리</b></span></div><div><br/></div><div>binary search tree 의 경우 최악의 상황에서 Right skewed tree나 left skewed tree 가 되면</div><div>검색을 위해 O(n)만큼의 노드 탐색이 소요된다.&nbsp;&nbsp;</div><div><br/></div><div>따라서 이를 보완하기 위해 나온 Balanced tree 의 일종이 B 트리이다.</div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/FFA5C39D-364C-4A25-93D4-DD3B0284AE3F.png" height="366" width="556"/></div><div><br/></div><div><b>차수가 m인 B트리의 특징은 다음과 같다. &nbsp;&nbsp;(m은 노드가 지닐 수 있는 최대 포인터 개수를 의미.)</b></div><div>1) 모든 노드는 많아도 m개의 자식을 가진다.&nbsp;&nbsp;</div><div>2) 리프노드가 아닌 내부 노드가 k 자식노드를 지닌다면 k-1개의 키를 보유하고 있다.</div><div>3) 루트는 리프노드가 아니라면 적어도 두개의 자식노드를 지닌다.</div><div>4) 루트를 제외한 모든 내부노드는 적어도 m/2개의 자식노드를 지닌다.&nbsp;&nbsp;</div><div>5) 모든 리프노드는 트리상에서 동일 레벨에 존재한다.&nbsp;&nbsp;</div><div>6)&nbsp;&nbsp;노드내의 데이터는 반드시 정렬된 상태여야 한다</div><div>7)&nbsp;&nbsp;입력 자료는 중복될 수 없다</div><div><br/></div><div><br/></div><div>삽입과정</div><div><br/></div><div>위 그림에서 키 0 을 삽입한다면, 7보다 작으므로 맨 왼쪽 자식노드에 삽입될 것이다.</div><div>0,1,2,5,6은 m의 차수를 벗어나므로 이 다섯 중에서 가운데 값인 2를 부모노드레벨로 올린다. <b>promoted</b></div><div>그리고 2를 기준으로 더 작은 서브트리, 더 큰 서브트리로 원래의 서브트리를 <b>split!!&nbsp;&nbsp;</b></div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/547B3941-4E3A-48B2-9DE1-A78E60C3CCA3.png" height="86" width="406"/></div><div><br/></div><div><br/></div><div>마찬가지로 부모 노드가 포화상태가 되면 부모노드도 split하고 그 가운데 값을 자신의 부모노드로 올린다.</div><div>루트노드가 포화상태가 되면, 루트노드를 두 개의 서브노드로 분할하고, 가운데 값을 새로운 루트로 지정한다.&nbsp;&nbsp;</div><div><br/></div><div>-13 추가시 차수 3인 b트리의 삽입 과정</div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/97FE5C5E-9484-4EBF-9410-79C5045D24F0.png" height="205" width="599"/></div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/0340E9F6-69CD-47AB-B7ED-2753B39E39C1.png" height="210" width="630"/></div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/4B47C224-F2C9-4F19-9606-D0D34EFEE049.png" height="212" width="626"/></div><div><br/></div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/3EC26EC9-6EC6-408C-9EF2-B5B489AF94FD.png" height="230" width="580"/></div><div><br/></div><div><b>B 트리 삽입</b></div><div>1) 추가할 값이 들어갈 리프노드를 찾는다.</div><div>2) 리프노드에 자리가 있다면 (m-개1 미만의 아이템 보유중이라면) 순서에 맞게 삽입하고,&nbsp;&nbsp;</div><div>2-b) 만약 리프노드가 full이면 리프노드를 작은 절반과 큰 절반의 두 노드로 분할하고,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;중간 값을 부모 노드로 Promote한다.</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 부모 노드도 full이면 부모노드도 분할하고, 더 위의 부모노드로 promote하는 과정을 반복. </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 루트노드에 도달하게 되면, B트리의 높이가 1 증가하게 된다.&nbsp;&nbsp; </div><div><br/></div><div><b>B 트리 삭제</b></div><div><b>m = 3, key 최대 2개 포함가능한 2-3 Tree의 예</b></div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/EA569673-F2BF-4B4C-96EE-DAD49F8A3876.png" height="294" width="560"/></div><div>1) 5나 7 제거 --&gt; 그냥 제거</div><div><b>2) 만약 15나 26을 지울 경우<span style="color: rgb(227, 0, 0);">&nbsp;&nbsp;-> Rotation with sibling&nbsp;&nbsp;</span></b></div><div><br/></div><div>&nbsp;&nbsp;15 삭제의 경우 : 형제노드의 키가 여유가 있으면 rotation 한다.&nbsp;&nbsp;</div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/E7E1AB87-14FC-443E-8EF5-8EB8BCD37641.png" height="416" width="510"/></div><div><br/></div><div>&nbsp;&nbsp;26 삭제의 경우 : 형제노드가 한개 뿐이다.&nbsp;&nbsp;</div><div>&nbsp;&nbsp;부모노드의 단계에서&nbsp;&nbsp;<b><span style="color: rgb(227, 0, 0);">Rotation with sibling 을 수행</span></b></div><div>&nbsp;&nbsp;그 경우 다음과 같이 우측 하단에 나타난 결과가 된다. (30의 형제노드는 7이므로 7을 올린다. 7의 각각의 자식노드는 유지.&nbsp;&nbsp;</div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/DFC41B49-C31E-4D57-B3E5-D91C82EC50B3.png" height="493" width="795"/></div><div><br/></div><div><br/></div><div><br/></div><div>만약 다음과 같이 중간노드(혹은 루트노드)를 지우는 경우, &nbsp;&nbsp;해당 노드의 inorder successor나 predecessor를 찾는 방식으로 진행한다.</div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/DAF0856B-4ADC-4C56-A76C-2C61649ECFE2.png" height="291" width="843"/></div><div><br/></div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/3777713E-AAAB-49E9-BDC9-85A5DF6F3680.png" height="184" width="536"/></div><div><br/></div><div>마찬가지로 왼쪽 자식노드가 비게 되므로 오른쪽 자식노드와 합친다.&nbsp;&nbsp;</div><div><br/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/7A3AD7DD-35C8-4E17-9069-6C64C311D246.png" height="178" width="341"/></div><div><br/></div><div>레벨이 맞지 않게 되므로,&nbsp;&nbsp;<b><span style="color: rgb(227, 0, 0);">Rotation with sibling 을 수행</span></b></div><div><b><span style="color: rgb(227, 0, 0);"><br/></span></b></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/D8D8AE14-C2A3-45B7-94DE-B174128645F6.png" height="187" width="555"/></div><div><br/></div><div><br/></div><div><hr/></div><div><span style="font-size: 32px;">B+ 트리</span></div><div>특징</div><div>1) 모든 데이터는 leaf nodes에 저장된다.</div><div>2) 모든 각 leaf node의 레벨은 같다.&nbsp;&nbsp;</div><div>3) 모든 leaf nodes는 다른 leaf nodes에 대한 링크(포인터)를 지닌다.</div><div><br/></div><div>B+트리의 차수(threshold) m = 2라고 하자.</div><div><br/></div><div><b>삽입과정&nbsp;&nbsp;</b></div><div><br/></div><div>root에 1) 50을 삽입하면 ok,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 75 삽입도 ok </div><div>root = leaf이므로</div><div><br/></div><div><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) 100 삽입시 차수 초과 </b></div><div><br/></div><div>각 데이터를 leaf로 보내야 한다. 다만 두개의 leaf node로 나눠서 보내야 한다.</div><div><br/></div><div>3-1) 다음과 같이 분할하였다고 하자. 부모노드의 75는 splitter의 역할을 하는 key이다.</div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/B41D3F14-26CF-40AD-8B71-73C3C56F880E.png" height="75" width="178"/></div><div>3-2 ) 두 노드를 잇는 포인터를 지정한다.&nbsp;&nbsp;</div><div><br/></div><div>4) 110 삽입시 역시 차수 초과로 다음과 같이 조정된다</div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/082B84CC-9DF6-4AE0-8D63-F165273062AB.png" height="98" width="206"/></div><div><img src="DB%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9D%B8%EB%8D%B1%EC%8B%B1%20%EA%B8%B0%EB%B2%95,%20B%20Tree,%20B+%20Tree%20%EB%93%B1.html.resources/37007F33-B74B-4A41-A962-3A6F9FFDA14F.png" height="89" width="230"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>